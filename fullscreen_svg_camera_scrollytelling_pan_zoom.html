<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fullscreen SVG Scrollytelling</title>
    <style>
      :root {
        --ink: #000000;
        --panel: #ffffffcc;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        overflow-x: hidden;
        background: #ffffff;
        color: var(--ink);
        font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
      }

      /* Fullscreen sticky stage */
      .stage-ctn {
        position: fixed;
        inset: 0;
        z-index: 0;
        width: 100vw;
        height: 80vh;
      }
      svg.stage {
        width: 100vw;
        height: 80vh;
        display: block;
        object-fit: cover;
        padding: 12vh 0 20vh;
      }

      /* Narrative overlay */
      .steps {
        position: relative;
        z-index: 1;
        max-width: 500px;
        margin-left: min(15vw, 200px);
        padding: 12vh 0 20vh;
      }
      .spacer {
        height: 5vh;
      }
      .step {
        margin: 0 0 65vh;
        background: var(--panel);
        backdrop-filter: blur(6px);
        border-radius: 12px;
        padding: 1.1rem 1.25rem;
      }
      .kicker {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-weight: 700;
        color: var(--muted);
      }

      /* Art layers */
      .layer {
        opacity: 0.85;
      }
      .labels {
        fill: #e5eef9;
      }

      /* Recorder panel */
      #recorder {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 2; /* above steps */
        width: 320px;
        background: #111;
        color: #eee;
        padding: 10px 12px;
        border-radius: 10px;
        font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
      }
      #recorder .hint {
        opacity: 0.75;
        margin: 6px 0 8px;
      }
      #recorder textarea {
        width: 100%;
        height: 140px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        resize: vertical;
      }

      /* toggling visibility for SVG images/layers */
      .toggle {
        opacity: 0;
        pointer-events: none;
      }
      .toggle.on {
        opacity: 1;
      }
      .fade {
        transition: opacity 400ms ease;
      }
    </style>
  </head>
  <body>
    <!-- FULLSCREEN BACKGROUND ART -->
    <div class="stage-ctn">
      <svg
        id="stage"
        class="stage"
        viewBox="0 0 1500 2000"
        xmlns="http://www.w3.org/2000/svg"
      >
        <!-- Static backdrop -->
        <image href="background.svg" x="0" y="0" width="1500" height="2000" />

        <!-- PNG overlay that we will show/hide via steps -->
        <image id="boom" class="toggle fade" href="sun.png" x="520" y="860"
        width="380" height="240" /* remove the line below if you want to
        preserve original PNG aspect */ preserveAspectRatio="none" />

        <!-- SCENE LAYERS (positioned in 1500x2000 space) -->
        <g id="sun" class="layer">
          <circle cx="750" cy="200" r="90" fill="#ffd166" />
          <circle
            cx="750"
            cy="200"
            r="140"
            fill="none"
            stroke="#ffd166"
            stroke-opacity="0.25"
            stroke-width="12"
          />
        </g>

        <g id="city" class="layer">
          <g fill="#1b2331">
            <rect x="800" y="1000" width="120" height="240" />
          </g>
        </g>

        <g id="hero" class="layer" transform="translate(520,800)">
          <circle cx="60" cy="40" r="36" fill="#888888" />
        </g>

        <!-- CAMERA TARGETS (you can hide strokes later; left visible for debugging) -->
        <g id="cam-wide" transform="translate(750,1000)">
          <rect
            x="0"
            y="0"
            width="100"
            height="2000"
            fill="none"
            stroke="red"
          />
        </g>
        <g id="cam-sun" transform="translate(750,200)">
          <rect
            x="470"
            y="0"
            width="340"
            height="500"
            fill="none"
            stroke="green"
          />
        </g>
        <g id="cam-city" transform="translate(750,800)">
          <rect
            x="-260"
            y="-160"
            width="520"
            height="320"
            fill="none"
            stroke="orange"
          />
        </g>
        <g id="cam-hero" transform="translate(580,800)">
          <rect
            x="-160"
            y="-150"
            width="320"
            height="300"
            fill="none"
            stroke="purple"
          />
        </g>
        <g id="cam-labels" transform="translate(700,780)">
          <rect
            x="-180"
            y="-130"
            width="360"
            height="260"
            fill="none"
            stroke="cyan"
          />
        </g>

        <!-- Big transparent hit layer for rectangle recorder (disabled until toggled) -->
        <rect
          id="hit-layer"
          width="1500"
          height="2000"
          fill="transparent"
          pointer-events="none"
        ></rect>
      </svg>
    </div>

    <!-- Recorder UI -->
    <div id="recorder">
      <label style="display: flex; gap: 0.5rem; align-items: center">
        <input type="checkbox" id="rec-on" />
        <span>Record camera rectangles</span>
      </label>
      <div class="hint">
        Drag on the art; hold <b>Shift</b> to snap to 10px.
      </div>
      <textarea id="rec-out" readonly></textarea>
    </div>

    <!-- NARRATIVE OVERLAY (scroll to trigger camera moves & toggles) -->
    <main class="steps" id="steps">
      <div class="spacer"></div>

      <section
        class="step"
        data-camera="#cam-wide"
        data-zoom="fit"
        data-speed="1200"
      >
        <div class="kicker"></div>
        <h1>Sabotazyści</h1>
        <p>Intro copy…</p>
        <p>Autorzy: Daniel Flis</p>
      </section>

      <!-- Show the PNG on this step -->
      <section
        class="step"
        data-camera="#cam-sun"
        data-zoom="cover"
        data-speed="1200"
        data-show="#boom"
      >
        <h2>Zoom to the sun</h2>
        <p>We tween the viewBox to a target box. PNG fades in here.</p>
        <p class="badge">Step 2</p>
      </section>

      <!-- Hide the PNG again -->
      <section
        class="step"
        data-camera="#cam-city"
        data-zoom="fit"
        data-padding="40"
        data-speed="1200"
        data-hide="#boom"
      >
        <h2>Pan across the skyline</h2>
        <p>
          <code>data-zoom</code> chooses <code>fit</code> vs <code>cover</code>.
        </p>
        <p class="badge">Step 3</p>
      </section>

      <section
        class="step"
        data-camera="#cam-hero"
        data-zoom="cover"
        data-padding="20"
        data-speed="1300"
      >
        <h2>Move in on the hero</h2>
        <p>Target boxes can be arbitrary.</p>
        <p class="badge">Step 4</p>
      </section>

      <section
        class="step"
        data-camera="#cam-labels"
        data-zoom="fit"
        data-speed="1000"
      >
        <h2>Callouts and details</h2>
        <p>Targets can be computed with <code>getBBox()</code> too.</p>
        <p class="badge">Step 5</p>
      </section>

      <section
        class="step"
        data-camera="#cam-wide"
        data-zoom="fit"
        data-speed="1000"
      >
        <h2>Reset to the wide view</h2>
        <p>One last pullback.</p>
        <p class="badge">Step 6</p>
      </section>

      <div class="spacer"></div>
    </main>

    <script>
      const svg = document.getElementById("stage");
      const steps = Array.from(document.querySelectorAll(".step"));

      /* ---------- Recorder (drag rectangles to define camera boxes) ---------- */
      const hit = document.getElementById("hit-layer");
      const recToggle = document.getElementById("rec-on");
      const recOut = document.getElementById("rec-out");
      const recPlacements = [];
      let recStart = null,
        recRubber = null;

      function toSvgPoint(evt) {
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
      }
      const snap10 = (n) => Math.round(n / 10) * 10;

      recToggle.addEventListener("change", () => {
        hit.setAttribute("pointer-events", recToggle.checked ? "all" : "none");
      });

      hit.addEventListener("pointerdown", (e) => {
        if (!recToggle.checked || e.button !== 0) return;
        hit.setPointerCapture(e.pointerId);
        e.preventDefault();

        const p = toSvgPoint(e);
        recStart = { x: p.x, y: p.y, snap: e.shiftKey };

        recRubber = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        recRubber.setAttribute("fill", "rgba(0,255,0,0.15)");
        recRubber.setAttribute("stroke", "lime");
        recRubber.setAttribute("stroke-dasharray", "6 6");
        svg.appendChild(recRubber);
      });

      hit.addEventListener("pointermove", (e) => {
        if (!recStart || !recRubber) return;
        const p = toSvgPoint(e);

        let x = Math.min(recStart.x, p.x);
        let y = Math.min(recStart.y, p.y);
        let w = Math.abs(p.x - recStart.x);
        let h = Math.abs(p.y - recStart.y);

        if (recStart.snap) {
          x = snap10(x);
          y = snap10(y);
          w = Math.max(10, snap10(w));
          h = Math.max(10, snap10(h));
        }

        recRubber.setAttribute("x", x);
        recRubber.setAttribute("y", y);
        recRubber.setAttribute("width", w);
        recRubber.setAttribute("height", h);
      });

      hit.addEventListener("pointerup", (e) => {
        if (!recStart || !recRubber) return;

        const x = +recRubber.getAttribute("x");
        const y = +recRubber.getAttribute("y");
        const w = +recRubber.getAttribute("width");
        const h = +recRubber.getAttribute("height");

        const id = `cam-${recPlacements.length + 1}`;

        // create a target group immediately
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.setAttribute("id", id);
        const r = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        r.setAttribute("x", x);
        r.setAttribute("y", y);
        r.setAttribute("width", w);
        r.setAttribute("height", h);
        r.setAttribute("fill", "none");
        r.setAttribute("stroke", "magenta");
        g.appendChild(r);
        svg.appendChild(g);

        // paste-ready snippet + history
        const snippet = `<g id="${id}"><rect x="${x.toFixed(1)}" y="${y.toFixed(
          1
        )}" width="${w.toFixed(1)}" height="${h.toFixed(1)}" fill="none"/></g>`;
        recPlacements.push({ id, x, y, w, h, snippet });
        recOut.value = JSON.stringify(recPlacements, null, 2);

        recRubber.remove();
        recRubber = null;
        recStart = null;
      });

      /* ---------- Camera math ---------- */
      const easeInOutCubic = (t) =>
        t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      const parseVB = (vb) => vb.split(/\s+/).map(Number); // [x,y,w,h]
      const setVB = (xywh) =>
        svg.setAttribute("viewBox", xywh.map((n) => +n.toFixed(3)).join(" "));
      const getCurrentVB = () => parseVB(svg.getAttribute("viewBox"));

      // Compute a viewBox that matches viewport aspect with 'fit' (contain) or 'cover' (crop)
      function fitBox(bbox, aspect, mode = "fit", pad = 0) {
        let { x, y, width: w, height: h } = bbox;
        w = Math.max(w, 1);
        h = Math.max(h, 1);

        // padding (expands the box outward)
        x -= pad;
        y -= pad;
        w += pad * 2;
        h += pad * 2;

        const boxAspect = w / h;

        if (mode === "cover") {
          // shrink the larger dimension so the result stays inside the box (crops)
          if (boxAspect > aspect) {
            // too wide -> reduce width
            const newW = h * aspect;
            x += (w - newW) / 2;
            w = newW;
          } else {
            // too tall -> reduce height
            const newH = w / aspect;
            y += (h - newH) / 2;
            h = newH;
          }
        } else {
          // 'fit': expand the smaller dimension so the whole box is visible (may include margins)
          if (boxAspect > aspect) {
            // too wide -> increase height
            const newH = w / aspect;
            y -= (newH - h) / 2;
            h = newH;
          } else {
            // too tall -> increase width
            const newW = h * aspect;
            x -= (newW - w) / 2;
            w = newW;
          }
        }
        return { x, y, width: w, height: h };
      }

      function getBBoxOfTarget(target) {
        const el =
          typeof target === "string" ? svg.querySelector(target) : target;
        if (!el) return { x: 0, y: 0, width: 1500, height: 2000 };
        const b = el.getBBox();
        return { x: b.x, y: b.y, width: b.width, height: b.height };
      }

      function animateToBox(destBox, duration = 1200) {
        const startVB = getCurrentVB();
        const endVB = [destBox.x, destBox.y, destBox.width, destBox.height];
        const start = performance.now();
        let rafId = null;

        function tick(now) {
          const t = Math.min(1, (now - start) / duration);
          const e = easeInOutCubic(t);
          const cur = startVB.map((s, i) => s + (endVB[i] - s) * e);
          setVB(cur);
          if (t < 1) rafId = requestAnimationFrame(tick);
        }
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(tick);
      }

      function goToTarget(selector, mode = "fit", pad = 0, duration = 1200) {
        const aspect = window.innerWidth / window.innerHeight;
        const bbox = getBBoxOfTarget(selector);
        const fitted = fitBox(bbox, aspect, mode, Number(pad) || 0);
        animateToBox(fitted, Number(duration) || 1200);
      }

      /* ---------- Toggle helpers (show/hide PNGs or layers) ---------- */
      const togglables = () => Array.from(svg.querySelectorAll(".toggle"));
      function setShow(list, on) {
        if (!list) return;
        list.split(",").forEach((sel) => {
          const el = svg.querySelector(sel.trim());
          if (el) el.classList.toggle("on", on);
        });
      }
      function applyTogglesForStep(stepEl) {
        if (!stepEl) return;
        const only = stepEl.dataset.only;
        const show = stepEl.dataset.show;
        const hide = stepEl.dataset.hide;
        if (only) {
          togglables().forEach((el) => el.classList.remove("on"));
          setShow(only, true);
        } else {
          setShow(show, true);
          setShow(hide, false);
        }
      }

      /* ---------- Scroll observer ---------- */
      function setShow(list, on) {
        if (!list) return;
        list.split(",").forEach((sel) => {
          const el = svg.querySelector(sel.trim());
          if (el) el.classList.toggle("on", on);
        });
      }

      const io = new IntersectionObserver(
        (entries) => {
          // Optional: process exits before enters to avoid flicker
          entries.sort(
            (a, b) => (a.isIntersecting ? 1 : 0) - (b.isIntersecting ? 1 : 0)
          );

          entries.forEach((entry) => {
            const s = entry.target;
            const active =
              entry.isIntersecting && entry.intersectionRatio > 0.55;
            s.classList.toggle("is-active", active);

            if (active) {
              // camera move
              goToTarget(
                s.dataset.camera,
                s.dataset.zoom || "fit",
                s.dataset.padding || 0,
                s.dataset.speed || 1200
              );

              // ENTER: apply visibility for this step
              if (s.dataset.only) {
                svg
                  .querySelectorAll(".toggle.on")
                  .forEach((el) => el.classList.remove("on"));
                setShow(s.dataset.only, true);
              } else {
                setShow(s.dataset.show, true);
                setShow(s.dataset.hide, false);
              }
            } else {
              // EXIT: undo this step’s changes (so items disappear on scroll back)
              if (s.dataset.only) setShow(s.dataset.only, false);
              if (s.dataset.show) setShow(s.dataset.show, false);
              if (s.dataset.hide) setShow(s.dataset.hide, true);
            }
          });
        },
        { threshold: [0, 0.55, 1], rootMargin: "-20% 0% -20% 0%" }
      );

      steps.forEach((s) => io.observe(s));

      /* ---------- Keep camera framed on resize ---------- */
      window.addEventListener("resize", () => {
        const current = document.querySelector(".step.is-active") || steps[0];
        if (current) {
          goToTarget(
            current.dataset.camera,
            current.dataset.zoom || "fit",
            current.dataset.padding || 0,
            0
          );
        }
      });

      /* ---------- First step on load (camera + toggles) ---------- */
      window.addEventListener("load", () => {
        const first = steps[0];
        first.classList.add("is-active");
        goToTarget(
          first.dataset.camera,
          first.dataset.zoom || "fit",
          first.dataset.padding || 0,
          0
        );
        applyTogglesForStep(first);
      });
    </script>
  </body>
</html>
